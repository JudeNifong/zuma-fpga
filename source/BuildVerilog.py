from structs import *
import globs
import math


#a helper function for write_LUTRAM
#returns a string '{ name1, name2 , ... }' for a given list of names
def list_to_vector(names):
    string = '{'
    for n in names:
        string = string + n + ','
    string = string[0:-1] + '}'
    return string


# write the verilog code for the LUTRAM.
# The LUTRAM can be a lutram of a routing mux, a ffmux or a eLUT
def write_LUTRAM(f, name, input_names, output_name, \
         config_offset, config_stage,  is_eLUT,  is_ffmux):

    #is it a regular mux or a mux on a ble?
    #the first input is the name of the LUTRAM wire of the lut .
    #remember that this LUTRAM have two outputs
    if is_ffmux:
        input_names.append(input_names[0] + '_unreg')
        input_names[0] = input_names[0] + '_reg'

    ## assign an 0 driver to every unconnected input
    while len(input_names) < globs.host_size:
        input_names.append("1'b0")

    #is it an eLUT or just a mux?
    if is_eLUT:
        string ='''
        elut_custom ''' + name + ''' ('''
    else:
        string ='''
        lut_custom ''' + name + ''' ('''

    string +='''
    .a(wr_addr), // input [5 : 0] a
    .d(wr_data[''' + str(config_offset) + ''']), // input [0 : 0]
    '''
    f.write(string)

    #connect the name of the input wires
    string = '.dpra(' + list_to_vector(input_names) + \
         '), // input [5 : 0] dpra'
    f.write(string)

    f.write('''
    .clk(clk), // input clk
    .we(wren[''' + str(config_stage) + ''']), // input we
    ''')
    #connect the name of the output wires.
    #if its an elut than we have two output wires instead of one
    if is_eLUT:
        f.write( '.dpo(' + output_name + \
             '_unreg), // unregistered output')

        f.write('''
        .qdpo_clk(clk2), // run clk
        .qdpo_rst(ffrst), // input flip flop reset
        ''')
        f.write( '.qdpo(' + output_name + \
             '_reg)); // registered output\n\n')
    else:
        f.write( '.dpo(' + output_name + '));\n\n')


##This function creates a verilog file,
##which represent the unconfigurated structure of the fpga
## param filename The filename of the verilog file.
def build_global_routing_verilog(filename):


## Because a mux can be implemented with sereval LUTRAMS,
## because of its input width, we have to track the the placment
## of a node of the node graph to its actual count and place of LUTRAMS.
## Therefore we use the config_patter array.
## The config_patter array describe this technolgy mapping,
## in form of array of nodeIds.
## every column in a row has a nodeId, and therfore a reference to a node
## in the node graph.
## more then one column can has the same reference, because there were
## sereval LUTRAMS used for that node.
## every row in the config_patter is called a stage
## where the adessable LUTRAMS of a stage are configured
## by the controller bit by bit
## the maximal number of LUTRAMS in a config row is the
## adressable size, i.e the config width of the controller.
## This config_patter array will also be written to the file configpattern.txt



    #start with the header
    f = open(filename, 'w')

    numinputs = 0
    numoutputs = 0
    for key in globs.IOs:

        numinputs = numinputs + len(globs.IOs[key].inputs)
        numoutputs = numoutputs + len(globs.IOs[key].outputs)

    header = """
    `include "define.v"
    //ZUMA global routing Entity
    //automatically generated by script
    module ZUMA_custom_generated
    #(
    """
    f.write(header)

    f.write('parameter N_NUMLUTS = ' + str(globs.params.N) + ',\n')
    f.write('parameter I_CLINPUTS = ' + str(globs.params.I) + ',\n')
    f.write('parameter K_LUTSIZE  = ' + str(globs.params.K) + ',\n')
    f.write('parameter CONFIG_WIDTH  = ' + str(globs.params.config_width)+ '\n')

    config_width = globs.params.config_width
    config_row = []
    header2 = """
     )
    (
    clk,
    fpga_inputs,
    fpga_outputs,
    config_data,
    config_en,
    progress,
    config_addr,
    clk2,
    ffrst
    );
    """
    f.write(header2)

    string = 'input [' + str(numinputs) +'-1:0]fpga_inputs;\n'
    f.write(string)
    string = 'input [' + str(32) +'-1:0]config_data;\n'
    f.write(string)
    string = 'input [CONFIG_WIDTH-1:0]config_addr;\n'
    f.write(string)
    string = 'input config_en;\n'
    f.write(string)
    string = 'output [ ' +  str(numoutputs)+ '-1:0]fpga_outputs;\n'
    f.write(string)
    string = 'output [15:0] progress;\n'
    f.write(string)
    f.write('wire [4096:0] wren;\n')
    f.write('wire [5:0]wr_addr;\n')
    f.write('wire [CONFIG_WIDTH-1:0] wr_data;\n')
    f.write('input clk;\n')
    f.write('input clk2;\n')
    f.write('input ffrst;\n')

    f.write('assign wr_data = config_data;\n');

    ##we use this config row to track the used LUTRAMS in this row
    config_row = []

    build_all = True #build the clusters

    registers = []

    ##write connections. one wire for every node output
    ##nodes graph has nodes for LUTS,Muxes channels,io,source and sinks.
    for node in globs.nodes:

        ## an eLut have two outputs.
        ## one registered and one unregistered output
        if node.eLUT:
            string = 'wire node_' + str(node.id) + '_reg;\n'
            string += 'wire node_' + str(node.id) + '_unreg;\n'
        ## the rest have only one output
        else:
            string = 'wire node_' + str(node.id) + ';\n'
        f.write(string)

    #connect the muxes output wires with the clusters output wires.
    for key in globs.clusters:
        cl = globs.clusters[key]
        for n in range(globs.params.N):
            lut_id = cl.LUT_FFMUX_nodes[n]
            opin_id = cl.outputs[n].id
            f.write('assign node_' + str(opin_id) + ' = node_' + str(lut_id) + ';\n')

    total_luts = 0
    ##generate code for every nodes. except source and sinks
    for node in globs.nodes:

        # this node is not driven. skip it.
        if len(node.inputs) < 1:
            continue

        # if the node have only one input we can just make a assigmnet
        # of the input with the ouput.
        node_prefix = 'node_'
        if len(node.inputs) == 1 and not node.ffmux:

             #other cases (IOs) are already dealt with
            if node.type is 5 or node.type is 6:
                f.write('assign ' + node_prefix + str(node.id) + ' = ' + node_prefix + str(node.inputs[0]) + ';\n');
                #todo is this needed?
                pass
            continue

        #create muxes
        n = node

        ## print debug information for every node, node type and location
        ## also set the right prefix
        mux_prefix = 'mux_'

        ##node sources and sinks will not be generated.
        if node.type < 3:
            continue
        elif n.type is 3: #OPIN
            if n.location[0] in [0, globs.clusterx] or n.location[1] in [0, globs.clustery]:
                #edge, thee are IOS
                f.write('//FPGA input at ' + str(n.location) + '\n')
            else:
                #cluster
                f.write('//cluster output at ' + str(n.location) + '\n')
        elif n.type is 4: #IPIN
            if n.location[0] in [0, globs.clusterx] or n.location[1] in [0, globs.clustery]:
                #edge, thee are IOS
                f.write('//FPGA output at ' + str(n.location) + '\n')
            else:
                #cluster
                f.write('//cluster input at ' + str(n.location) + '\n')
        elif n.type is 5 or n.type is 6: #CHANX
            if n.type is 5:
                f.write('//sbox driver x at  ' + str(n.location) + '\n')
            else:
                f.write('//sbox driver y at ' + str(n.location) + '\n')
        elif n.type is 10: #global IO
            if len(n.edges) == 0:
                f.write('//global output ordering node for output #' + str(globs.orderedOutputs.index(n.id)) + '\n')
            else:
                f.write('//global input ordering node for input #' + str(globs.orderedInputs.index(n.id)) + '\n')
        elif n.eLUT: #ELUT
            f.write('//internal cluster node (eLUT) at  ' + str(n.location) + '\n')
            mux_prefix = 'c_mux_'
            #print "LUT! " + str(n.location) + " " + str(n.id)
        elif n.ffmux: #FFMUX
            f.write('//internal cluster node (ffmux) at  ' + str(n.location) + '\n')
            mux_prefix = 'c_mux_'
            #print "FFMUX! " + str(n.location) + " " + str(n.id)
        else:
            f.write('//internal cluster node at  ' + str(n.location) + '\n')
            mux_prefix = 'c_mux_'

        f.write('//size: ' + str(len(n.inputs)) + '\n//inputs: ' + str(n.inputs) + '\n')

        ## now we have to write the LUTRAM.
        ## first we have to check if we must split the LUTRAM,
        ## because it has too much input edges.

        #the input width
        mux_size = len(node.inputs)

        # number of used LUTRAMS +1 ?
        # TODO: why hostsize -1?
        num_luts = int(math.ceil((mux_size-globs.host_size)/(globs.host_size-1.0)) + 1)

        # the node doesn't fit in a single LUTRAM
        if num_luts > globs.host_size + 1:
            level_size = mux_size
            num_luts = 0
            while level_size > 1:
                level_size = int(math.ceil((level_size*1.0) / globs.host_size))
                num_luts += level_size
        total_luts = num_luts + total_luts

        ##if a node with its LUTRAMS can't fit in a row we finished that row and use the next.
        ##TODO: is this accaptable?
        if num_luts + len(config_row) >= config_width:
            globs.config_pattern.append(config_row)
            config_row = []

        # a node fit in a single LUTRAM. write it to the file and append
        #the node id to the current config row
        if mux_size <= globs.host_size:
            write_LUTRAM(f, mux_prefix + str(node.id), \
                     [(node_prefix + str(i)) for i in node.inputs], \
                     node_prefix + str(node.id), \
                     len(config_row), len(globs.config_pattern), \
                     node.eLUT,  node.ffmux )
            config_row.append( node.id)

        #the node fits in the square of the hostsize.
        #write the LUTRAMS to file and append
        #the node ids to the current config row
        elif mux_size <= globs.host_size*globs.host_size:
            #find number of LUTs needed
            # max lutsize = 6+5*(n-1)

            num_luts = int(math.ceil((mux_size-globs.host_size)/(globs.host_size-1.0)) + 1)
            count = 0
            mux_nodes = []
            for n in range(num_luts - 1):
                node_name = node_prefix + \
                        str(node.id) + '_' + str(count)
                f.write( '\t\t\twire ' + node_name + ';\n')
                mux_nodes.append(node_name)
                write_LUTRAM(f, mux_prefix + str(node.id) \
                         + '_' + str(count), \
                         [(node_prefix + str(i)) for i in node.inputs[count:count+globs.host_size]], \
                         node_name,
                         len(config_row), \
                         len(globs.config_pattern), node.eLUT, \
                         node.ffmux )
                count = count + globs.host_size
                config_row.append( node.id)
            write_LUTRAM(f, mux_prefix + str(node.id), mux_nodes + \
                     [(node_prefix + str(i)) for i in node.inputs[count:]], \
                     node_prefix + str(node.id) ,
                     len(config_row), len(globs.config_pattern), \
                     node.eLUT,  node.ffmux )
            config_row.append( node.id)

        # if it even doesn't fit into the k^2 size
        #need to code if we ever need this
        # quick approach: Not as tightly packed as above case
        # In this approach every LUT
        # only serves one level (depth)
        else:
            count = 0
            level_size = int(math.ceil((mux_size*1.0)/globs.host_size))
            mux_nodes = []
            # Level 0 (input nodes)
            for n in range(level_size - 1):
                node_name = node_prefix + str(node.id) + \
                        '_' + str(count)
                f.write( '\t\t\twire ' + node_name + ';\n')
                mux_nodes.append(node_name)
                write_LUTRAM(f, mux_prefix + str(node.id) + \
                         '_' + str(count), \
                         [(node_prefix + str(i)) for i in node.inputs[count:count+globs.host_size]], \
                         node_name, len(config_row), \
                         len(globs.config_pattern), \
                         node.eLUT,  node.ffmux )
                count = count + globs.host_size
                config_row.append( node.id )

            node_name = node_prefix + str(node.id) + \
                    '_' + str(count)
            f.write( '\t\t\twire ' + node_name + ';\n')
            mux_nodes.append(node_name)
            write_LUTRAM(f, mux_prefix + str(node.id) + \
                     '_' + str(count), \
                     [(node_prefix + str(i)) for i in node.inputs[count:]],\
                     node_name,
                     len(config_row), len(globs.config_pattern), \
                     node.eLUT,  node.ffmux )
            config_row.append( node.id )

            # Further levels
            level_size = int(math.ceil((level_size*1.0)/globs.host_size))
            level = 0
            next_level_mux_nodes = []
            while level_size > 1:
                count  = 0
                level += 1
                for n in range(level_size - 1):
                    node_name = node_prefix + \
                            str(node.id) + '_' + \
                            str(count) + '_' + \
                            str(level)
                    f.write( '\t\t\twire ' + \
                         node_name + ';\n')
                    next_level_mux_nodes.append(node_name)
                    write_LUTRAM(f, mux_prefix + \
                             str(node.id) + '_' + \
                             str(count) + '_' + \
                             str(level), \
                             [str(i) for i in mux_nodes[count:count+globs.host_size]],\
                             node_name, \
                             len(config_row), \
                             len(globs.config_pattern), \
                             node.eLUT, node.ffmux )
                    count = count + globs.host_size
                    config_row.append( node.id )
                node_name = node_prefix + str(node.id) + \
                        '_' + str(count) + '_' + str(level)
                f.write( '\t\t\twire ' + node_name + ';\n')
                next_level_mux_nodes.append(node_name)
                write_LUTRAM(f, mux_prefix + str(node.id) + \
                         '_' + str(count) + \
                         '_' + str(level), \
                         [str(i) for i in mux_nodes[count:]], \
                         node_name,
                         len(config_row), \
                         len(globs.config_pattern), \
                         node.eLUT,  node.ffmux )
                config_row.append( node.id )
                level_size = int(math.ceil((level_size*1.0)/globs.host_size))
                mux_nodes = next_level_mux_nodes
                next_level_mux_nodes = []

            # Write last level (single LUT)
            write_LUTRAM(f, mux_prefix + str(node.id), mux_nodes, node_prefix + str(node.id),
                len(config_row), len(globs.config_pattern),  node.eLUT,  node.ffmux )   
            config_row.append( node.id )

    globs.config_pattern.append(config_row)

    # save the config pattern array to the file
    configfile = open('configpattern.txt', 'w')
    for row in globs.config_pattern:
        for item in row:
            configfile.write(str(item)+ ' ')

        configfile.write('\n')

    configfile.close()

    # now build the rest
    print 'total luts: ', total_luts

    count = 0
    if globs.params.orderedIO:
        #connect the order outputs node wires with the fpga outputs
        for output in globs.orderedOutputs:
            f.write('assign fpga_outputs[' + str(count) + \
                '] = node_' + str(output) + ';\n')
            count += 1
    else:
        for key in globs.IOs:
            IO = globs.IOs[key]
            for i in IO.outputs:
                f.write('assign fpga_outputs[' + str(count) + '] = node_' + str(i.id) + ';\n')
                count = count+1

    count = 0
    if globs.params.orderedIO:
        #connect the order inputs node wires with the fpga inputs
        for input in globs.orderedInputs:
            f.write('assign node_' + str(input) + \
                ' = fpga_inputs[' + str(count) + '];\n')
            count += 1
    else:
        for key in globs.IOs:
            IO = globs.IOs[key]
            for i in IO.inputs:
                f.write('assign node_' + str(i.id) + ' = fpga_inputs[' + str(count) + '];\n')
                count = count+1


    # write the config controller
    f.write('parameter NUM_CONFIG_STAGES = ' + \
        str(len(globs.config_pattern)) + ';')
    string = """
    config_controller_simple
    #(
        .WIDTH(CONFIG_WIDTH),
        .STAGES(NUM_CONFIG_STAGES),
        .LUTSIZE(K_LUTSIZE)
    )
    configuration_ctrl
    (
        .clk(clk),
        .reset(1'b0),
        .wren_out(wren),
        .progress(progress),
        .wren_in(config_en),
        .addr_in(config_addr),
        .addr_out(wr_addr)
    );
    """
    f.write(string)
    f.write('endmodule')
